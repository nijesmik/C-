> **출처** <br>
> 📚 [전문가를 위한 C++](https://product.kyobobook.co.kr/detail/S000201305611)

# 배열

## 기본 타입 배열

프로그램에서 배열에 대한 메모리를 할당하면 실제 메모리에서도 연속된 공간을 할당한다. 이때 메모리의 한 칸은 배열의 한 원소를 담을 수 있는 크키로 할당된다. 예를 들어 다섯 개의 int 값으로 구성된 배열을 다음과 같이 로컬 변수로 선언하면 스택에 메모리가 할당된다.

```c++
int myArray[5];
```

배열을 힙에 선언할 때도 비슷하다. 배열의 위치를 가리키는 포인터를 사용한다는 점만 다르다. 다음의 코드는 int 값 다섯 개를 담는 배열에 메모리를 할당해서 그 공간을 가리키는 포인터를 `myArrayPtr`란 변수에 저장한다.

```c++
int myArrayPtr = new int[5];
```

`new[]`를 호출한 횟수만큼 `delete[]`를 호출해서 배열에 할당했던 메모리를 해제하도록 코드를 작성해야 한다. 예를 들면 다음과 같다.

```c++
delete[] myArrayPtr;
myArrayPtr = nullptr;
```

## 객체 배열

객체에 대한 배열도 기본 타입 배열과 비슷하다. `N`개의 객체로 구성된 배열을 `new[N]`으로 할당하면 객체를 담기에 충분한 크기의 `N`개 블록이 연속된 공간에 할당된다. `new[]`를 호출하면 각 객체마다 **디폴드 생성자**가 호출된다. 그래서 `new[]`로 객체 배열을 할당하면 형식에 맞게 초기화된 객체 배열을 가리키는 포인터가 리턴된다. 예를 들어 다음 클래스를 보자.

```c++
class Simple {
public:
    Simple() {}
    ~Simple() {}
}
```

네 개의 `Simple` 객체로 구성된 배열을 할당하면 위 `Simple` 생성자가 네 번 호출된다.

```c++
Simple *mySimpleArray = new Simple[4];
```

배열에 대한 메모리를 `new[]`로 할당하면 반드시 `new[]`를 호출한 수만큼 `delete[]`를 호출해서 메모리를 해제해야 한다. `delete[]`를 호출하면 할당된 메모리를 해제할 뿐만 아니라 각 원소의 객체마다 소멸자를 호출한다.

```c++
Simple* mySimpleArray = new Simple[4];
delete[] mySimpleArray;
mySimpleArray = nullptr;
```

배열 버전의 delete인 `delete[]`를 사용하지 않으면 프로그램이 이상하게 동작할 수 있다. 어떤 컴파일러는 객체를 가리키는 포인터만 삭제한다고 여기고 배열의 첫 번째 원소에 대한 소멸 자만 호출하는데, 그러면 배열의 나머지 원소에 접근할 수 없게 된다. 또 어떤 컴파일러는 `new` 와 `new[]`에 대한 메모리 할당 방식이 서로 전혀 달라서 메모리 손상(memory corruption)이 발생하기도 한다.

배열의 원소가 객체일 때만 모든 원소에 대해 소멸자가 호출된다. 포인터 배열에 대해 `delete[]`를 호출할 때는 각 원소가 가리키는 객체를 일일이 해제해야 한다. 예를 들면 다음과 같다.

```c++
const size_t size = 4;
Simple** mySimplePtrArray = new Simple*[size];

// 포인터마다 객체를 할당한다.
for (size_t 1 = 0; 1 < size; i++) {
    mySimplePtrArray[i] = new Simple():
}

// 할당된 객체를 삭제한다.
for (size_t 1 = 0; 1 < size; 1++) {
    delete mySimplePtrArray[i];
}

// 배열을 삭제한다.
delete[] mySimplePtrArray;
mySimplePtrArray = nullptr;
```

## 다차원 배열

### 다차원 스택 배열

```c++
char board[R][C] = {};
```

스택에 생성한 이차원 배열의 메모리는 두 개의 축을 사용하지 않고 주소가 지정된 일차원 배열처럼 나열되며, 배열의 크기와 이를 접근하는 방식만 다르다.

### 다차원 힙 배열

```c++
char** board = new char[R][C]; // 버그! 컴파일 오류가 발생한다.
```

힙 배열에 대한 메모리 할당 방식은 스택 배열과 다르기 때문에 이렇게 작성하면 컴파일 에러가 발생한다. 힙에서는 메모리 공간이 연속적으로 할당되지 않기 때문에 스택 방식의 다차원 배열처럼 메모리를 할당하면 안 된다.

힙 배열의 첫 번째 인덱스(`R`)에 해당하는 차원의 배열을 연속적인 공간에 먼저 할당한다. 그런 다음 이 배열의 각 원소에 두 번째 인덱스(`C`)에 해당 하는 차원의 배열을 가리키는 포인터를 저장한다.

하위 배열을 할당하는 작업은 컴파일러에서 자동으로 처리할 수 없다. 첫 번째 차원의 배열이 가리키는 각 원소(하위 배열)에 대한 메모리는 마치 일차원 힙 배열을 할당 하듯이 직접 하나씩 할당해야 한다.

```c++
char** myArray = new char*[R]: // 첫 번째 차원의 배열을 할당한다.

for (size_t i = 0; i < R; i++) {
    myArray[i] = new char[C]; // i번째 하위 배열을 할당한다.
}
```

다차원 힙 배열에 할당된 메모리를 해제할 때도 마찬가지로 `delete[]`로 하위 배열을 해제할 수 없기 때문에 일일이 해제해야 한다. 다차원 힙 배열을 해제하는 코드는 할당하는 코드와 연산을 반대로 수행할 뿐 형태는 거의 비슷하다.

```c++
for (size_t  i= 0; i < R; i++) {
    delete[] myArray[i]: // i번째 하위 배열을 해제한다.
}

delete[] myArray; // 첫 번째 차원의 배열을 해제한다.
```
