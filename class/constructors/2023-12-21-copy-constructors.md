> **출처** <br>
> 📚 [전문가를 위한 C++](https://product.kyobobook.co.kr/detail/S000201305611)

# 복사 생성자

C++에서는 **복사 생성자**라는 특수한 생성자를 제공한다. 다른 객체와 똑같은 객체를 생성할 때 이를 사용한다. 복사 생성자를 직접 작성하지 않으면 컴파일러가 대신 만들어준다. 컴파일러가 생성한 복사 생성자는 데이터 멤버가 기본 타입이라면 똑같이 복사하고, 객체 타입이라면 그 객체의 복사 생성자를 호출한다.

`SpreadsheetCell` 클래스에 복사 생성자를 추가하면 다음과 같다.

```c++
class SpreadsheetCell {
public:
    SpreadsheetCell(const SpreadsheetCell& src);
};
```

복사 생성자는 원본 객체에 대한 const 레퍼런스를 인수로 받는다. 다른 생성자와 마찬가지로 리턴값은 없다. 생성자 안에서 원본 객체에 있는 데이터 멤버를 모두 복사한다. 물론 구체 적인 동작은 원하는 대로 얼마든지 바꿔도 되지만, 관례를 벗어나지 않는 것이 바람직하므로 새로 만들 객체의 데이터 멤버를 모두 기존 객체의 데이터 멤버로 초기화한다.

## 복사 생성자가 호출되는 경우

C++에서 함수에 인수를 전달할 때 기본적으로 값으로 전달된다(값 전달 방식이 적용된다). 다시 말해 함수나 메서드는 값이나 객체의 복사본을 받는다. 따라서 함수나 메서드에 객체를 전달하면 컴파일러는 그 객체의 복사 생성자를 호출하는 방식으로 초기화한다. 예를 들어 다음과 같이 string 매개변수를 값으로 받는 `printString()` 함수가 있다고 하자.

```c++
void printString(string inString) {
    std::cout << inString << std::endl;
}
```

코드에서 `printstring()`에 string 매개변수를 전달해서 호출하면 string 매개변수인 `inString` 은 이 클래스의 복사 생성자를 호출하는 방식으로 초기화된다. 이 복사 생성자의 인수가 바로 `printstring()`에 전달한 string이다. 다음과 같이 `printstring()`에서 매개변수를 `name`으로 지정해서 호출하면 `inString` 객체를 초기화할 때 string의 복사 생성자가 실행된다.

```c++
std::string name = "heading one";
printString(name); // name을 복제한다.
```

`pranstring()` 메서드가 실행을 마치면 `inString`이 삭제된다. 이 값은 실제로 `name`의 복사본 이므로 `name`은 원래 값 그대로 남아 있다. 물론 복사 생성자에 매개변수를 const 레퍼런스로 전달하면 복제 오버헤드를 줄일 수 있다.

## 복사 생성자 명시적으로 호출하기

복사 생성자를 명시적으로 호출할 수도 있다. 주로 다른 객체를 똑같이 복사하는 방식으로 객체를 만들 때 이 방식을 사용한다. 예를 들어 `SpreadSheetCell` 객체의 복사본을 만들려면 다음과 같이 작성한다.

```c++
SpreadsheetCell myCell1(4);
SpreadsheetCell myCell2(myCell1):
```

## 명시적으로 디폴트로 만든 복사 생성자와 명시적으로 삭제된 복사 생성자

컴파일러가 생성한 복사 생성자를 명시적으로 디폴트로 만들거나 삭제할 수 있다.

```c++
SpreadsheetCell(const SpreadsheetCell& src) = default;
// 또는
SpreadsheetCell(const SpreadsheetCell& src) = delete;
```

복사 생성자를 삭제하면 객체를 더 이상 복제할 수 없다. 객체를 값으로 전달하지 않게 할 때 이렇게 설정한다.

## 컴파일러가 생성하는 생성자에 대한 정리

컴파일러는 모든 클래스에 디폴트 생성자와 복제 생성자를 자동으로 만들어준다. 그런데 프로그래머가 직접 작성한 생성자에 따라 컴파일러에서 자동으로 만들어주는 생성자가 달라질 수 있다. 복제 생성자를 명시적으로 정의하지 않는 한 컴파일러는 무조건 복제 생성자를 만든다. 반면 어떤 생성자라도 정의했다면 컴파일러는 디폴트 생성자를 만들지 않는다.
